//
//  TerrainGenerator.fragmentshader
//  Tutorials
//
//  Created by Fabian Achammer on 10.12.15.
//
//

#version 330 core

// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 LightDirection_cameraspace;
in vec3 Vertex_color;
in float Vertex_slope;

// Ouput data
out vec4 color;

uniform mat4 MV;
uniform mat4 V;
uniform vec3 LightPosition_worldspace;
uniform sampler2D heightSlopeBasedColorMap;
uniform float maxNegativeHeight;
uniform float maxPositiveHeight;
uniform float baseRadius;

struct ColorStop {
    float time;
    vec4 color;
};

float map(float value, float inMin, float inMax, float outMin, float outMax) {
    return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

// Returns the linearly interpolated color from the given color stops and argument time
// Assumes that colorStops is sorted
// time and the colorStops time must be on the same scale
vec4 colorFromTimeInColorStops(ColorStop[2] colorStops, float time) {
    if(colorStops.length() == 0)
        return vec4(0, 0, 0, 1);
    
    if(colorStops.length() == 1)
        return colorStops[0].color;
    
    if(time <= colorStops[0].time)
        return colorStops[0].color;
    
    if(time >= colorStops[colorStops.length() - 1].time)
        return colorStops[colorStops.length() - 1].color;
    
    for(int i = 0; i < colorStops.length() - 1; i++) {
        ColorStop stopA = colorStops[i];
        ColorStop stopB = colorStops[i + 1];
        
        if(time >= stopA.time && time <= stopB.time) {
            float mappedTime = map(time, stopA.time, stopB.time, 0, 1);
            return mix(stopA.color, stopB.color, mappedTime);
        }
    }
    
    return vec4(0, 0, 0, 1);
}

vec3 colorFromHeight(float height, float slope) {
    if(height > 0 && height <= 100)
        return vec3(0.11, 0.42, 0.63);
    
    if(height > 100 && height <= 103)
        return vec3(0.92, 0.76, 0.53);
    
    if(height > 103 && height <= 108 && slope > 0.6)
        return vec3(0.3, 0.3, 0.3);
    
    return vec3(0.95, 0.95, 0.95);
}

void main() {
    // Light emission properties
    // You probably want to put them as uniforms
    vec3 LightColor = vec3(1, 1, 1);
    float LightPower = 500000.0f;
    
    // Material properties
    vec2 heightSlopeBasedColorMapSize = textureSize(heightSlopeBasedColorMap, 0);
    float heightCoordinate = clamp(map(length(Position_worldspace),
                                       baseRadius - maxNegativeHeight,
                                       baseRadius + maxPositiveHeight, 0, 1), 0, 1);
    
    float slopeCoordinate = clamp(map(log(Vertex_slope + 1), 0, log(1000), 0, 1), 0, 1);
    vec2 textureCoordinates = vec2(heightCoordinate, slopeCoordinate);
    vec4 MaterialDiffuseColor = texture(heightSlopeBasedColorMap, textureCoordinates);
    vec4 MaterialAmbientColor = vec4(0.1, 0.1, 0.1, 1.0) * MaterialDiffuseColor;
    
    vec3 position_cameraspace = (V * vec4(Position_worldspace, 1.0)).xyz;
    
    // Distance to the light
    float distance = length(LightPosition_worldspace - Position_worldspace);
    LightPower /= distance * distance;
    
    vec3 n = normalize( Normal_cameraspace );
    vec3 l = normalize( LightDirection_cameraspace );
    float ndotL = clamp( dot( n,l ), 0,1 );

    vec4 diffuseLight = LightPower * ndotL * vec4(LightColor, 1);

    color = MaterialAmbientColor + MaterialDiffuseColor * diffuseLight;
}

