//
//  TerrainGenerator.fragmentshader
//  Tutorials
//
//  Created by Fabian Achammer on 10.12.15.
//
//

#version 330 core

// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 LightDirection_cameraspace;
in vec3 Vertex_color;
in float Vertex_slope;

// Ouput data
out vec4 color;

uniform mat4 MV;
uniform mat4 V;
uniform vec3 LightPosition_worldspace;
uniform sampler2D heightSlopeBasedColorMap;
uniform float maxNegativeHeight;
uniform float maxPositiveHeight;
uniform float baseRadius;

struct ColorStop {
    float time;
    vec4 color;
};

float map(float value, float inMin, float inMax, float outMin, float outMax) {
    return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

void main() {
    // Light emission properties
    // You probably want to put them as uniforms
    vec3 LightColor = vec3(1, 1, 1);
    float LightPower = 500000.0f;
    
    // Material properties
    vec2 heightSlopeBasedColorMapSize = textureSize(heightSlopeBasedColorMap, 0);
    float heightCoordinate = clamp(map(length(Position_worldspace),
                                       baseRadius - maxNegativeHeight,
                                       baseRadius + maxPositiveHeight, 0, 1), 0, 1);
    
    float slopeCoordinate = clamp(map(log(Vertex_slope + 1), 0, log(1000), 0, 1), 0, 1);
    vec2 textureCoordinates = vec2(heightCoordinate, slopeCoordinate);
    vec4 MaterialDiffuseColor = texture(heightSlopeBasedColorMap, textureCoordinates);
    vec4 MaterialAmbientColor = vec4(0.1, 0.1, 0.1, 1.0) * MaterialDiffuseColor;
    
    vec3 position_cameraspace = (V * vec4(Position_worldspace, 1.0)).xyz;
    
    // Distance to the light
    float distance = length(LightPosition_worldspace - Position_worldspace);
    LightPower /= distance * distance;
    
    vec3 n = normalize( Normal_cameraspace );
    vec3 l = normalize( LightDirection_cameraspace );
    float ndotL = clamp( dot( n,l ), 0,1 );

    vec4 diffuseLight = LightPower * ndotL * vec4(LightColor, 1);

    color = MaterialAmbientColor + MaterialDiffuseColor * diffuseLight;
}

